# Kolibri API

Этот документ описывает минимальный сервер API Kolibri, который запускается
утилитой `kolibri_server` и автоматически активируется скриптом `kolibri.sh up`.
Сервер реализует REST и gRPC (заглушка на TCP) интерфейсы, предназначенные для
локального прототипирования и быстрой проверки интеграций.

## Запуск сервера

```bash
cmake -S . -B build
cmake --build build
./build/kolibri_server --rest-port 8080 --grpc-port 7000
```

При запуске без параметров сервер поднимает оба интерфейса: REST на порту `8080`
и gRPC-заглушку на порту `7000`. Скрипт `./kolibri.sh up` собирает проект, строит
фронтенд, гарантирует наличие `kolibri_server` и запускает его параллельно с
`kolibri_node`.

Доступные опции командной строки:

| Параметр          | Описание                                                |
|-------------------|---------------------------------------------------------|
| `--rest-port N`   | Порт REST API (по умолчанию `8080`).                     |
| `--grpc-port N`   | Порт gRPC-заглушки (по умолчанию `7000`).                |
| `--no-rest`       | Выключить REST API.                                     |
| `--no-grpc`       | Выключить gRPC-заглушку.                                 |
| `-h`, `--help`    | Показать справку.                                       |

## REST API

REST-сервер отвечает минимальным набором запросов в формате HTTP/1.1 с JSON
ответами.

### `GET /health`

Проверка работоспособности сервера.

- **Ответ 200 OK**
  ```json
  { "status": "ok" }
  ```

### `GET /v1/metrics`

Запрос текущих метрик работы прототипа.

- **Ответ 200 OK**
  ```json
  { "uptime": 0, "pending_jobs": 0 }
  ```

Значения являются заглушками и предназначены для тестирования цепочек
интеграции.

### `POST /v1/evaluate`

Принимает произвольное тело запроса (например, JSON) и подтверждает, что задача
поставлена в очередь.

- **Ответ 202 Accepted**
  ```json
  { "message": "evaluation scheduled" }
  ```

### Ошибки

Любой другой маршрут возвращает ответ `404 Not Found` с телом:

```json
{ "error": "not found" }
```

Некорректные HTTP запросы получают `400 Bad Request`.

## gRPC (TCP) заглушка

Колибри пока не использует настоящую gRPC-библиотеку; вместо этого запускается
простая TCP-служба, эмулирующая RPC-вызов. Подключитесь к порту gRPC и отправьте
любую строку (например, `PING`). Сервер ответит сообщением:

```
ACK:kolibri
```

Это поведение удобно для быстрой проверки наличия соединения и будущих
интеграций: приложения могут открывать TCP-соединение, отправлять сериализованный
пакет и ожидать подтверждения.

## Архитектура сервера

`kolibri_server` запускает отдельные потоки для REST и gRPC-заглушки. Потоки
обслуживают входящие подключения и аккуратно завершаются при получении сигналов
`SIGINT`/`SIGTERM`, когда основной процесс инициирует остановку. Сокеты
закрываются с использованием потокобезопасных атомарных операций.

## Интеграция со скриптом `kolibri.sh`

Команда `./kolibri.sh up` теперь:

1. Собирает все бинарники с помощью CMake.
2. Собирает фронтенд и убеждается, что готов WebAssembly.
3. Запускает `kolibri_server` в фоне (REST `8080`, gRPC `7000`).
4. Запускает `kolibri_node` и завершает сервер после остановки ноды.

Если `kolibri_server` не стартует (например, порт занят), команда прерывается с
ошибкой и сообщает об этом пользователю.
