# Decimal Cognition Layer / Слой десятичного мышления / 十进制认知层

**Copyright (c) 2025 Кочуров Владислав Евгеньевич**

---

## 1. Goals / Цели / 目标

- Унифицировать внутреннее представление знаний в виде цифр `0–9`.
- Обеспечить обратимую трансформацию текстовых данных.
- Подготовить данные для дальнейшей обработки формульным пулом.

---

## 2. API Summary / Сводка API / API 概览

| Function | Description |
|----------|-------------|
| `size_t k_encode_text_length(size_t input_len);` | Возвращает длину буфера цифр для строки длиной `input_len`. |
| `int k_encode_text(const char *input, char *out, size_t out_len);` | Кодирует UTF-8 строку в последовательность цифр (ASCII `0`–`9`). |
| `size_t k_decode_text_length(size_t digits_len);` | Оценивает длину строки при декодировании. |
| `int k_decode_text(const char *digits, char *out, size_t out_len);` | Восстанавливает оригинальный текст из десятичного представления. |

Возврат `0`/`-1` сигнализирует о нехватке буфера или неверных данных.

---

## 3. Encoding Scheme / Схема кодирования / 编码方案

### Русский
Каждый байт текста преобразуется в три десятичные цифры (000–255). Пример: символ `A` (0x41) → `065`. В результате строка «Hi» становится `072105`.

### English
Each byte is turned into a zero-padded decimal triplet (`000`–`255`). The encoded string length equals `input_len * 3`.

### 中文
每个字节转换为三位十进制数字（前导零补齐），编码后的长度为 `input_len * 3`。

---

## 4. Buffer Management / Управление буферами / 缓冲区管理

1. Вызовите `k_encode_text_length` для определения размера выходного массива.
2. Добавьте один байт под завершающий `\0`.
3. При декодировании учитывайте, что длина должна делиться на 3.

---

## 5. Error Handling / Обработка ошибок / 错误处理

- Нулевые указатели → `-1`.
- Недостаточный `out_len` → `-1`.
- Недопустимые символы (не цифры) при декодировании → `-1`.

---

## 6. Usage Example / Пример использования / 使用示例

```c
char digits[64];
if (k_encode_text("Kolibri", digits, sizeof(digits)) == 0) {
    // digits содержит последовательность цифр
}
```

---

## 7. Integration Notes / Заметки по интеграции / 集成说明

- Входы REPL и сетевые сообщения проходят через этот слой.
- Результаты обучения, записываемые в геном, также могут кодироваться для совместимости между узлами.

