# Kolibri Improvement Checklist

This document captures 100 concrete upgrade tasks for Kolibri-Σ, grouped by functional area so parallel teams can execute without overlap.

## Recommended next steps

To maximize impact in the short term, prioritize a thin vertical slice that improves runtime performance, resilience, and user experience in parallel:

1. **Ship SIMD-ready WASM builds (tasks 1–4, 47)** — enabling `-msimd128`, providing scalar fallbacks, and bundling strict Emscripten flags will unlock immediate latency gains for both native and threaded WASM targets.
2. **Harden the observe/learn path (tasks 29–38)** — adding source flags, text normalization, and rehearsal safeguards reduces drift and gives product teams confidence to re-enable on-device adaptation.
3. **Introduce cache-aware mini-VM primitives (tasks 21–28)** — a minimal interpreter with profiling counters pays dividends for determinism, caching, and later JIT upgrades.
4. **Deliver PWA resiliency features (tasks 55–63)** — COOP/COEP headers, Service Worker caching, and offline indicators are prerequisites for stable threaded WASM in Chromium-based browsers.
5. **Close the profiling loop (tasks 39–45)** — exposing key counters in both CLI and UI helps validate the previous workstreams and gives rapid feedback on regressions.

Each stream can progress independently but should converge in a combined release where profiling dashboards confirm latency wins, the UI surfaces the new controls, and the learning pipeline remains safe by default.

## Ядро C/WASM: производительность и память
1. Включить `-msimd128` и условное ветвление по `__wasm_simd128__` со скалярным фолбэком.
2. Переписать горячие суммирующие циклы на SIMD-интринсики (`i32x4`, `wasm_u16x8_*`).
3. Вынести горячие функции в `static inline` и пометить `__attribute__((always_inline))`.
4. Реализовать beam-декод 4–8 lanes с опциональной поддержкой `PTHREADS`.
5. Ввести lock-free счётчики частот (atomic `uint32_t`) для observe-потоков.
6. Добавить слотовый аренатор (slab allocator) для автоматов и кеша формул.
7. Реализовать ring-buffer входного текста с backpressure при переполнении.
8. Перейти на q8/q16 хранение логитов и биасов с масштабами и on-the-fly dequant.
9. Разнести hot/cold сегменты памяти, холодные данные вынести на отдельные страницы.
10. Предварительно выделять пулы под 10× локальные автоматы для минимизации фрагментации.

## Алгоритмы и устойчивость
11. Добавить контрфактуальный CF-beam с 3–5 параллельными кандидатами.
12. Внедрить лагранжевые штрафы `λB/λD` и онлайн-регулировку по окну 128 шагов.
13. Реализовать фазовый резонанс второго порядка с когерентностью соседних узлов.
14. Делать адаптивную длину слов/фраз по энтропии и return-rate в аттрактор.
15. Ввести обратимые скетчи R-Sketch64/96 с 2–3 байтами trace-hint на эмит.
16. Запретить обучение на собственных ответах по умолчанию (анти-эхо, снижение веса AI-текста).
17. Балансировать реплей-буфер отдельными квотами для свежих/старых и человек/ИИ примеров.
18. Дедуплицировать observe-примеры по sketch-hash с порогом Хэмминга ≤2.
19. Проводить хард-валидацию инвариантов перед эмиссией и отклонять нарушения B/D.
20. Реализовать top-k anneal: сужать `topk` и снижать `T` в устойчивом контексте.

## Мини-VM и кэш формул
21. Добавить мини-VM с 20–30 опкодами (`OP_EMIT`, `OP_GOTO`, `OP_BIAS`, `OP_END`).
22. Джит-компилировать частые VM-программы в специализированные планки.
23. Построить кеш формул по ключу sketch64(input) с open-addressing и нагрузкой ≤0.7.
24. Использовать политику вытеснения LFUDA вместо LRU.
25. Сохранять топ-N кеш-слов в снапшот для тёплого старта.
26. Делать инкрементальные сбросы кеша при нехватке памяти (cap-aware eviction).
27. Встроить проверку аудит-пути: replay мини-VM и сверка с кешом.
28. Экспортировать в профиль счётчики cache hit/miss и отображать их в UI.

## Наблюдение и локальное обучение
29. Расширить `k_observe(st, buf, len, flags)` флагами источника: USER/AI/CORR/IMPORT.
30. Балансировать домены (диалоги, документы, команды) через разные веса.
31. Выбирать окна обучения на 32–128 токенов с 50% overlap.
32. Добавить встроенную нормализацию текста: NFC, trim, collapse whitespace.
33. Подключить опциональный стемминг/сегментацию для RU/EN отдельным модулем.
34. Реализовать мини-RAG: локальный индекс скетчей и top-k ближайших фрагментов.
35. Ограничить импорт внешних данных дневным лимитом и требовать явное согласие.
36. Встроить контроль катастрофического забывания через периодический mix-rehearsal.
37. Добавить маркеры в UI (`!nolearn`) для запрета обучения на сообщении.
38. Сохранять снапшоты только адаптеров как дельты к базовому состоянию.

## Профилирование и бенчи
39. Расширить `k_profile` таймерами observe/decode/vote/sketch/daawg/alloc.
40. Собирать счётчики cache hit/miss, рост `λB/λD` и долю отказов по инвариантам.
41. Подготовить мини-бенч-набор на 500–1000 строк с выводом JSON и UI-графиками.
42. Автоматически запускать микро-бенчи SIMD/скаляр при первом старте (warm-up).
43. Измерять латентность/слово P50/P90 в скользящих окнах и выводить в UI.
44. Подсвечивать алерты в UI, если P90 превышает целевой порог.
45. При деградации метрик выполнять откат к предыдущему снапшоту.

## Сборка, флаги и совместимость
46. Удалить `USE_PTHREADS`, использовать `-s PTHREADS=1 -pthread` в строгом режиме.
47. Всегда собирать с `-s STRICT=1 -s STANDALONE_WASM --no-entry -msimd128`.
48. Экспортировать функции через `-s EXPORTED_FUNCTIONS="['_foo','_bar']"`.
49. Добавить режим сборки `WASM_THREADS=1 ./scripts/install.sh`.
50. Проверять наличие `emcc` в PATH и выдавать понятную ошибку.
51. Позволить переопределять `EMCC` и `CFLAGS` через переменные окружения.
52. Поддерживать три таргета: wasm (браузер), wasm-wasi (CLI), native (debug-инструменты).
53. Генерировать SBOM и sha256-хеши для релизных артефактов.
54. Собирать universal zip/tar пакеты и `install.sh` с проверками окружения.

## PWA, браузер и сервер
55. Включить COOP/COEP заголовки в dev-сервере для поддержки SAB/threads.
56. Реализовать Service Worker с cache-first для ядра и stale-while-revalidate для UI.
57. Сделать офлайн-фоллбек страницу и восстановление очереди запросов.
58. Добавить потоковый ответ в UI с кнопкой «Stop» для отмены генерации.
59. Вынести на главную кнопки «Учить», «Профиль», «Сброс ядра», «Сохранить снапшот».
60. Подготовить пресеты профиля (краткий, подробный, технический, дружелюбный).
61. Показать виджет метрик с `λB/λD`, `top-k`, `T`, hits/misses и P50/P90.
62. Индикатор режима OFFLINE/ONLINE при подключении retrieval.
63. Добавить переключатель локализации UI (ru/en) в шапке.
64. Реализовать тёмную и светлую темы с автоопределением по media-query.

## Чат: UX уровня GPT
65. Хранить историю диалогов в IndexedDB и поддерживать экспорт/импорт `.json`.
66. Разрешить правку подсказки на месте с диффом и повторной отправкой.
67. Добавить быстрые команды `/help`, `/learn on|off`, `/reset`, `/snapshot save|load`.
68. Включить кнопку копирования ответа и корректное Markdown-форматирование.
69. Встроить офлайн-пакет highlight.js для подсветки кода.
70. Разрешить drag-and-drop вложений `.txt/.md/.pdf` с локальным извлечением текста.
71. Добавить кнопки 👍/👎, пробрасывая метки CORR/NOLEARN в observe().
72. Автоопределять язык общения и применять политику обучения по источнику.
73. Ввести пресет «безопасный тон» с мягким пост-процессом.
74. Показать onboarding-карточки для первых шагов пользователя.

## Безопасность и приватность
75. Шифровать снапшоты XChaCha20-Poly1305 с ключом из ОС-хранилища.
76. Управлять разрешениями: по умолчанию без интернета, плагины — только с согласием.
77. Санитизировать входы/выходы в UI (escape HTML).
78. Ограничивать размер входа до 64 КБ и делить на чанки при необходимости.
79. Лимитировать обращения к внешним источникам (rate-limit).
80. Ввести приватный режим без сохранения истории и реплея.

## Интеграции (опционально)
81. Реализовать retrieval-плагин с HTTP-fetch и отображением источников.
82. Добавить плагин-калькулятор `k_tool_call("calc", "12+34")` как пример SDK.
83. Создать локальный плагин даты/времени без сетевых разрешений.
84. Определить SDK для плагинов: JSON-манифест + WASM-модуль функций.
85. Поддержать режим «ограниченные плагины» только для локальных устройств.
86. Организовать экспорт/импорт набора плагинов через manifest.

## Тестирование и качество
87. Написать юнит-тесты ядра: sketch, VM, cache, penalize, observe/decode.
88. Добавить интеграционные тесты WASM-границы (malloc/free, буферы).
89. Запустить fuzz-тесты парсинга VM и observe-ввода на native-таргете.
90. Проверять совместимость снапшотов: новые версии читают старые файлы.
91. Настроить E2E Playwright-тесты офлайн-режима и SW-кэша.
92. Организовать smoke-сборки на macOS и Linux в CI-матрице.

## Документация и DX
93. Обновить README таблицей флагов и матрицей совместимости браузеров.
94. Написать гайд по профилировщику: чтение `λB/λD` и ключевых метрик.
95. Подготовить руководство по плагинам с минимальным примером и API.
96. Сформулировать локальную политику приватности для конечных пользователей.
97. Вести CHANGELOG по SemVer с релизными тегами и SBOM.

## Релиз и DevOps
98. Собирать релиз-артефакты (ZIP/TAR) с `install.sh`, SBOM и подписью ed25519.
99. Настроить CI-релизы (GitHub Actions) для сборки WASM, упаковки и проверок суммы.
100. Подготовить офлайн crash-bundle: собирать технические метаданные и предлагать архив пользователю.

